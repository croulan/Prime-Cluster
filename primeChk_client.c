
////////////////////////////////////////////////////////////////////////////////
/*//////////////////////////////////////////////////////////////////////////////
 *
 * Program: primeChk_client.c primeChk_server.c primeChk.x primeChk.h 
 *  primeChk_clnt.c primeChk_svc.c primeChk_xdr.c
 *
 * Programmed By: Roulan Ceniza
 *
 * COMPILE:
 *  Make sure you're cd'd in the right directory and run: 
 *
 *      make -f Makefile.primeChk 
 *  
 * RUNNING:
 *  This program is dependent on rpcbind, a program not in stock Ubuntu 15.10.
 *  It it essentail that you are able to install and run the service which you
 *  can do so with the below command: 
 *
 *      sudo apt-get install rpcbind
 *      rpcbind start
 *
 *  rpcbind may notify you that another instacnce of if it is already running
 *  but should be okay.
 *
 *  You should be able run the programs now which will require two terminals. 
 *  In one terminal run the command (server side):
 *      
 *      sudo ./primeChk_server 
 *
 *  In the other terminal, run the command (client side) where the <num1> is a 
 *  number which you want to check is prime: 
 *
 *      ./primeChk_client localhost <num1>
 *  
 *
 * DESCRIPTION: 
 *  This porgam demonstartes a distributive server/client architechure using 
 *  an RPC protocol which tells whether a number is prime or not. If a number 
 *  is less than ten thousand, then the computational load will be put soley
 *  on the server side. If above and equal to ten thousand, then the load will 
 *  be split in half betweent the client and the server where the client will
 *  get the lower half of the computation and the server will get the upper
 *  portion.
 *
 *
 * NOTE: 
 *  Most of the code seen in the directory was auto generated by rpcgen, a linux
 *  command for streamlining rpc development of which I took advantage of. The 
 *  files that were created/edited by my work for this project were primeChk.x,
 *  primeChk_client.c, primeChk_server.c, and primeChk.h.
 *  
 * Arguments: 
 *      int primeness_prog_1(char *host, int num, int split) 
 *          Arg: host
 *          Dir: Input
 *          Type: char* 
 *          Is the IP address the client connects to
 *          Arg: num
 *          Dir: input
 *          Type: int
 *          The number we need to check for primeness 
 *          Arg: split 
 *          Dir: Input
 *          Type: int 
 *          A sential value to determine with to slipt processing load
 *
 *      int checkLowerPrimeness(int upperLimit)
 *          Arg: upperLimit
 *          Dir: Input
 *          Type: int 
 *          The upper limit bound for the client when the processing is split
 *          
 * Auto generated RPC header stub:
 *  This is sample code generated by rpcgen.
 *  These are only templates and you can use them
 *  as a guideline for developing your own functions.
 *
 *//////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////

#include <sys/time.h>
#include <math.h>
#include "primeChk.h"

int checkLowerPrimeness(int);

// Technically the RPC call I believe 
int primeness_prog_1(char *host, int num, int split) {
	CLIENT *clnt;
	int  *result_1;
	prime_t  primeness_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, PRIMENESS_PROG, PRIMENESS_V1, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
    primeness_1_arg.checkPrime = num;

    // the call to the server which tells us if it evaluated a prime or not 
    // return = 1 if prime
	result_1 = primeness_1(&primeness_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

    if(*result_1) { 
        return 1;   // server side is prime
    } else { 
        return 0;   // server side is not prime 
    }

}

// Client side of the program will check the lower bound of the computation of 
// the prime.
int main (int argc, char *argv[]) {
	char *host;
    int passed_prime, lowerIsPrime, upperIsPrime;
    struct timeval start, stop;
    long start_mil, stop_mil;

	if (argc != 3) {
		printf ("usage: %s server_host num1\n", argv[0]);
		exit (1);
	}

    if ((passed_prime = atoi(argv[2])) == 0 && *argv[2] != '0') {
        fprintf(stderr, "invalid value: %s\n", argv[2]);
        exit(1);

    }

    host = argv[1];

    // check to see if passed_prime is big enough to split load calculation
    if (passed_prime >=10000) {
        lowerIsPrime = checkLowerPrimeness((int) floor(passed_prime/2));

        // start of rpc call
        gettimeofday(&start,NULL);
        upperIsPrime = primeness_prog_1 (host, passed_prime, 1);

        // end of rpc call
        gettimeofday(&stop, NULL); 
        
        // Honestly don't know why this works but it does so Ill go with it
        if (!((lowerIsPrime == upperIsPrime) == 1)) {
            printf("#%d is Prime?: TRUE\n", passed_prime);

        } else { 
            printf("#%d is Prime?: FLASE\n", passed_prime);
            
        }

    } else {
        // start of rpc call
        gettimeofday(&start,NULL);
        upperIsPrime = primeness_prog_1 (host, passed_prime,0);

        // end of rpc call
        gettimeofday(&stop, NULL); 

        if(upperIsPrime) { 
            printf("%d is Prime?: TRUE\n", passed_prime);

        } else {
            printf("%d is Prime?: FALSE\n", passed_prime);

        }
    
    }

    // converts start and stop to miliseconds
    start_mil = (start.tv_sec)*1000 + (start.tv_usec)/1000;
    stop_mil = (stop.tv_sec)*1000 + (stop.tv_usec)/1000;

    printf("Execution time of RPC: %ld ms.\n", (stop_mil - start_mil));
    exit (0);
}

// If upper limit does not have any perfect divisors, return 1 else 0
int checkLowerPrimeness(int upperLimit){
    int i; 

    printf("%s\n", "Checking lower limit function invoked");
    for (i = 2; i<upperLimit/2; i++) {
        if (upperLimit%i == 0) {
            // found a perfect divisor
            return 0;

        }

    }

    return 1;

}
